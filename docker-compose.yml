# Production Docker Compose for co-found
# Deployed at: /opt/docker/co-found
# Total memory limit: 4.7 GiB (60% of 7.8 GiB system RAM, NO SWAP)
# 
# IMPORTANT: This file assumes:
# - App image is pre-built and tagged (e.g., co-found-app:1.0.0)
# - .env file exists with 600 permissions in project root
# - All images are version-pinned (no :latest tags)

services:
  # Reverse proxy - ONLY service allowed to bind to host ports 80/443
  traefik:
    image: traefik:v2.10
    container_name: co-found-traefik
    restart: unless-stopped
    # Resource limits: lightweight reverse proxy
    mem_limit: 256m
    cpus: 0.5
    # Bounded logging to prevent disk exhaustion
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    command:
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --providers.docker.network=co-found-internal
      - --entryPoints.web.address=:80
      - --entryPoints.websecure.address=:443
      - --entryPoints.web.http.redirections.entryPoint.to=websecure
      - --entryPoints.web.http.redirections.entryPoint.scheme=https
      - --certificatesResolvers.letsencrypt.acme.httpChallenge=true
      - --certificatesResolvers.letsencrypt.acme.httpChallenge.entryPoint=web
      - --certificatesResolvers.letsencrypt.acme.email=${LETSENCRYPT_EMAIL}
      - --log.level=INFO
      - --api.dashboard=false  # Disable dashboard in production (remove port 8080 if not needed)
    ports:
      - "80:80"
      - "443:443"
    volumes:
      # NOTE: Traefik REQUIRES Docker socket for auto-discovery of services
      # This is read-only (ro) and necessary for Traefik to function
      # If Docker socket mounting is prohibited, use nginx with static config instead
      - /var/run/docker.sock:/var/run/docker.sock:ro
      # Named volume for ACME certificates
      - co-found-traefik-acme:/acme.json
    networks:
      - co-found-internal
    healthcheck:
      # Check if Traefik is responding (port 8080 API, but dashboard disabled above)
      # Fallback: check if main ports are listening
      test: ["CMD-SHELL", "timeout 1 bash -c '</dev/tcp/localhost/80' || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # PostgreSQL database - largest memory allocation for query performance
  db:
    image: postgres:15-alpine
    container_name: co-found-db
    restart: unless-stopped
    # Resource limits: database needs most memory for buffers and connections
    mem_limit: 2g
    cpus: 1.0
    # Bounded logging
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    # Load secrets from .env file
    env_file:
      - .env
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      POSTGRES_DB: ${POSTGRES_DB:-cofound_prod}
    # Named volume only (no anonymous volumes)
    volumes:
      - co-found-postgres-data:/var/lib/postgresql/data
      - ./schema.sql:/docker-entrypoint-initdb.d/01-schema.sql:ro
    networks:
      - co-found-internal
    # NO host ports exposed - only accessible via internal network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # Redis cache - moderate memory for caching and rate limiting
  redis:
    image: redis:7-alpine
    container_name: co-found-redis
    restart: unless-stopped
    # Resource limits: cache service, moderate memory
    mem_limit: 512m
    cpus: 0.5
    # Bounded logging
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    # Named volume only (no anonymous volumes)
    volumes:
      - co-found-redis-data:/data
    networks:
      - co-found-internal
    # NO host ports exposed - only accessible via internal network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # Main application - Node.js Express server
  # IMPORTANT: Image must be pre-built and version-pinned (e.g., co-found-app:1.0.0)
  # Build command (run on CI/build server):
  #   docker build -t co-found-app:1.0.0 -f Dockerfile .
  app:
    image: co-found-app:1.0.0  # CHANGE THIS to your actual version tag
    container_name: co-found-app
    restart: unless-stopped
    # Resource limits: Node.js app, significant memory for V8 heap
    mem_limit: 1.5g
    cpus: 1.0
    # Bounded logging
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    # Load all environment variables from .env
    env_file:
      - .env
    environment:
      # Core environment
      NODE_ENV: production
      PORT: 3001
      # Database configuration (using service name 'db' from internal network)
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      POSTGRES_DB: ${POSTGRES_DB:-cofound_prod}
      DB_HOST: db
      DB_PORT: 5433
      DB_NAME: ${POSTGRES_DB:-cofound_prod}
      DB_USER: ${POSTGRES_USER:-postgres}
      DB_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      DATABASE_URL: postgresql://${POSTGRES_USER:-postgres}:${POSTGRES_PASSWORD:-postgres}@db:5433/${POSTGRES_DB:-cofound_prod}
      # Redis configuration (using service name 'redis' from internal network)
      REDIS_URL: redis://redis:6380
      # Security / JWT (must be set in .env)
      JWT_SECRET: ${JWT_SECRET}
      # Frontend URLs
      VITE_API_URL: ${VITE_API_URL:-https://co-found.uz}
      VITE_FRONTEND_URL: ${VITE_FRONTEND_URL:-https://co-found.uz}
      # Google OAuth (optional, from .env)
      VITE_GOOGLE_CLIENT_ID: ${VITE_GOOGLE_CLIENT_ID:-}
    # NO host ports exposed - only accessible via Traefik reverse proxy
    # Internal port 5000 only, accessible on co-found-internal network
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    # Named volume for uploads (no anonymous volumes)
    volumes:
      - co-found-app-uploads:/app/uploads
    networks:
      - co-found-internal
    # Traefik labels for routing (app accessible only through reverse proxy)
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.cofound.rule=Host(`co-found.uz`)"
      - "traefik.http.routers.cofound.entrypoints=websecure"
      - "traefik.http.routers.cofound.tls.certresolver=letsencrypt"
      - "traefik.http.services.cofound.loadbalancer.server.port=3001"
      # www -> non-www redirect
      - "traefik.http.routers.cofound-www.rule=Host(`www.co-found.uz`)"
      - "traefik.http.routers.cofound-www.entrypoints=websecure"
      - "traefik.http.routers.cofound-www.tls.certresolver=letsencrypt"
      - "traefik.http.routers.cofound-www.middlewares=redirect-to-nonwww@docker"
      - "traefik.middlewares.redirect-to-nonwww.redirectregex.regex=^https?://www\\.(.*)"
      - "traefik.middlewares.redirect-to-nonwww.redirectregex.replacement=https://co-found.uz/$$1"
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3001/api/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)}).on('error', () => process.exit(1))\" || exit 1"]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 30s

# Named volumes only (compliance: no anonymous volumes)
volumes:
  co-found-postgres-data:
    driver: local
  co-found-redis-data:
    driver: local
  co-found-app-uploads:
    driver: local
  co-found-traefik-acme:
    driver: local

# Private internal network (compliance: not using default bridge)
networks:
  co-found-internal:
    driver: bridge
    # internal: false allows Traefik to access external services (Let's Encrypt)
    # But app/db/redis are only accessible within this network
