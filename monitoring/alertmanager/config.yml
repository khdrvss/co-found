global:
  resolve_timeout: 5m

# Default route receiver - change this to match a configured receiver (slack/email/webhook)
route:
  receiver: 'slack-notifications'

receivers:
  - name: 'team-notifications'
    # Example webhook receiver (keep or replace)
    webhook_configs:
      - url: 'https://example-webhook.example.com/'

  # Example Slack receiver. Replace `https://hooks.slack.com/services/...` with your Slack Incoming Webhook URL
  # or mount it as a file/secret when running Alertmanager in production.
  - name: 'slack-notifications'
    slack_configs:
      - api_url: 'https://hooks.slack.com/services/REPLACE_ME'
        channel: '#cofound-alerts'
        username: 'alertmanager'
        title: '{{ .CommonLabels.alertname }}'
        text: '{{ range .Alerts }}*{{ .Labels.severity | toUpper }}* - {{ .Annotations.summary }}\n{{ .Annotations.description }}\n{{ end }}'

  # Example email receiver. Configure smtp_smarthost, auth_username, auth_password appropriately.
  - name: 'email-notifications'
    email_configs:
      - to: 'oncall@example.com'
        from: 'alertmanager@example.com'
        smarthost: 'smtp.example.com:587'
        auth_username: 'alertmanager@example.com'
        auth_password: 'REPLACE_WITH_SECURE_PASSWORD'

# NOTE: For production, you should populate the API URLs / credentials using Docker secrets or environment
# file mounts rather than committing them to the repository. Example strategies:
# - Use Docker secrets and reference the secret file in the Alertmanager config (or use a templating step at deploy time).
# - Use a configuration management system (Ansible/Chef) to render a final `config.yml` on the server.

# Inhibit rules / route customizations can be added below to avoid noisy alerts during maintenance windows.
